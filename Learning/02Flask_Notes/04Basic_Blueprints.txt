What is a Flask Blueprint?

Concept:
A Blueprint is like a mini Flask app inside our main app.
It helps us to organize routes, templates, and static files modularly.

Why use it:
Helps keep your project clean as it grows.
Makes it easier to reuse code across projects.
Allows multiple developers to work on different modules independently.

Analogy:
Think of your Flask app as a city. Blueprints are like districtsâ€”each district has its own streets (routes), buildings (templates), and utilities (static files).

Steps to Use Flask Blueprints

Create a project folder
Set up a virtual environment -Isolate dependencies for the project.
Create an app/ folder-This will contain all your Flask app code.
Create a routes/ folder inside app/-Each module or feature will have its own file (e.g., auth.py, blog.py).
Create a templates/ folder inside app/-Optional for backend-only projects; needed if rendering HTML later.
Create a routes/folder inside app/-This is blueprints in each route file(Blueprint represents a set of routes for a module/feature.)
Create __init__.py inside app/
Create app.py at the root-Entry point to run the Flask app using the app factory

my_flask_app/
â”‚
â”œâ”€â”€ venv/                  # Virtual environment folder (created via python -m venv venv)
â”‚
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py        # Initializes Flask app and registers blueprints
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ __init__.py    # Can be empty or used to import all blueprints
â”‚   â”‚   â”œâ”€â”€ auth.py        # Auth-related routes
â”‚   â”‚   â””â”€â”€ blog.py        # Blog-related routes
â”‚   â””â”€â”€ templates/         # Placeholder folder, can be empty
â”‚
â”œâ”€â”€ config.py              # Configurations (dev/prod)
â”œâ”€â”€ requirements.txt       # Project dependencies
â””â”€â”€ app.py                 # Entry point to run app

Steps to Use Flask Blueprints

Create a project folder
Set up a virtual environment - Isolate dependencies for the project.
Create an app/ folder - This will contain all your Flask app code.
Create a routes/ folder inside app/ - Each module or feature will have its own file (e.g., auth.py, blog.py).
Create a templates/ folder inside app/ - Optional for backend-only projects; needed if rendering HTML later.
Create blueprints in each route file inside routes/ - Blueprint represents a set of routes for a module/feature.
Create __init__.py inside app/ - Initialize Flask app and register all blueprints.
Create app.py at the root - Entry point to run the Flask app using the app factory.
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚   app.py      â”‚
             â”‚ (Entry Point) â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚ __init__.py   â”‚
             â”‚ (App Factory) â”‚
             â”‚               â”‚
             â”‚ - Creates app â”‚
             â”‚ - Registers   â”‚
             â”‚   blueprints  â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                       â”‚
         â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ blog.py       â”‚         â”‚ another_bp.py â”‚
â”‚ (Blueprint)   â”‚         â”‚ (Blueprint)   â”‚
â”‚ /blog/        â”‚         â”‚ /shop/        â”‚
â”‚ /blog/post    â”‚         â”‚ /shop/item    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
my_flask_app/

â”‚
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ routes/
â”‚       â””â”€â”€ blog.py
â”œâ”€â”€ app.py
â””â”€â”€ requirements.txt

Before Blueprints (Simple Flask App)

We usually just wrote everything in app.py (or main.py):
from flask import Flask
app = Flask(__name__)

@app.route("/")
def home():
    return "Hello World"

if __name__ == "__main__":
    app.run(debug=True)


ðŸ‘‰ All routes, configs, and logic lived in one file.

After Blueprints (Modular Approach)
Now we split things:
app/__init__.py â†’ creates the app (create_app()), registers blueprints.
app/routes/... â†’ holds different blueprints (modular routes).
app.py â†’ only responsible for running the app.
So instead of putting everything in app.py, we move the app creation logic to __init__.py.

Analogy
Before: app.py was the kitchen â†’ cooking, serving, and running everything.
After: __init__.py is the kitchen (prepares food, sets menu = blueprints).
app.py is just the waiter (starts the restaurant, serves food).


Step 1
app.py 
if(__name__=="__main__):
    app.run()

Step 2:
app/__init__.py
    import flask
    createapp Function create and return app

Step 3:
Import app in app.py
start the terminal

Step 4:
routes\blog.py
Importing Flask modules-from flask import Blueprint, jsonify
Create a blueprint-blog_bp = Blueprint('blog', __name__)
Define a route for blueprint

Step 5:
app/__init__.py
Register the blueprint
    import blueprint >> routes/blog file
    from .routes.blog import blog_bp
in create_app 
    >register the blueprint
    app.register_blueprint(blog_bp, url_prefix='/blog')

register_blueprint() â†’ built-in Flask method of the app instance.
blog_bp â†’ the blueprint we want to register (user-defined object).
url_prefix='/blog' â†’ optional prefix added to all routes in this blueprint.
    Example: @blog_bp.route('/') â†’ /blog/
    Example: @blog_bp.route('/post') â†’ /blog/post
Purpose: Connects the blueprint to the app so Flask knows about the blueprintâ€™s routes.



Request comes â†’ app.py calls create_app() â†’ app instance created â†’ blueprint registered â†’ route matched â†’ function executed â†’ response returned
